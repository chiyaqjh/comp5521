<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>COMP5521 åˆçº¦æµ‹è¯•å¹³å°</title>
    <script src="https://cdn.jsdelivr.net/npm/web3@latest/dist/web3.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 40px;
            line-height: 1.6;
        }
        .container {
            max-width: 1000px;
            margin: 0 auto;
        }
        .section {
            margin: 20px 0;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 10px;
            background: white;
        }
        button {
            padding: 10px 20px;
            font-size: 14px;
            background: #f6851b;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background: #e2761b;
        }
        button:disabled {
            background: #cccccc;
            cursor: not-allowed;
        }
        .status {
            margin: 10px 0;
            padding: 10px;
            border-radius: 5px;
            font-weight: bold;
        }
        .success {
            background: #d4ffd4;
            color: #006400;
            border: 1px solid #00ff00;
        }
        .error {
            background: #ffd4d4;
            color: #8b0000;
            border: 1px solid #ff0000;
        }
        .loading {
            background: #fffacd;
            color: #8b8000;
            border: 1px solid #ffd700;
        }
        input, textarea {
            padding: 8px;
            margin: 5px;
            border: 1px solid #ccc;
            border-radius: 4px;
            width: 400px;
        }
        .info-box {
            background: #e8f4fd;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
        }
        .contract-address {
            font-family: monospace;
            font-size: 12px;
            background: #f0f0f0;
            padding: 5px;
            border-radius: 3px;
        }
        .tab {
            overflow: hidden;
            border: 1px solid #ccc;
            background-color: #f1f1f1;
            border-radius: 5px;
        }
        .tab button {
            background-color: inherit;
            float: left;
            border: none;
            outline: none;
            cursor: pointer;
            padding: 14px 16px;
            transition: 0.3s;
            color: #333;
        }
        .tab button:hover {
            background-color: #ddd;
        }
        .tab button.active {
            background-color: #ccc;
        }
        .tabcontent {
            display: none;
            padding: 6px 12px;
            border: 1px solid #ccc;
            border-top: none;
            border-radius: 0 0 5px 5px;
        }
        .nft-item {
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            background: white;
        }
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="section">
            <h1>ğŸ”— COMP5521 åˆçº¦æµ‹è¯•å¹³å°</h1>
            <p>æµ‹è¯•ç¨³å®šå¸ã€NFTå’Œå¸‚åœºåˆçº¦åŠŸèƒ½</p>
        </div>

        <!-- è¿æ¥é’±åŒ…åŒºåŸŸ -->
        <div class="section">
            <h2>ğŸ”— æ­¥éª¤1: è¿æ¥é’±åŒ…</h2>
            <button onclick="connectMetaMask()" id="connectBtn">è¿æ¥ MetaMask</button>
            <div id="walletStatus"></div>
            <div id="walletInfo" style="display: none;">
                <div class="info-box">
                    <p><strong>é’±åŒ…åœ°å€ï¼š</strong><span id="accountAddress" class="contract-address"></span></p>
                    <p><strong>ç½‘ç»œï¼š</strong><span id="networkName"></span> | <strong>é“¾IDï¼š</strong><span id="chainId"></span></p>
                </div>
            </div>
        </div>

        <!-- é€‰é¡¹å¡ -->
        <div class="tab">
            <button class="tablinks" onclick="openTab(event, 'Stablecoin')">ğŸ’° ç¨³å®šå¸æµ‹è¯•</button>
            <button class="tablinks" onclick="openTab(event, 'NFT')">ğŸ¨ NFTæµ‹è¯•</button>
            <button class="tablinks" onclick="openTab(event, 'Marketplace')">ğŸª å¸‚åœºæµ‹è¯•</button>
            <button class="tablinks" onclick="openTab(event, 'Debug')">ğŸ› è°ƒè¯•ä¿¡æ¯</button>
        </div>

        <!-- ç¨³å®šå¸æµ‹è¯•æ ‡ç­¾é¡µ -->
        <div id="Stablecoin" class="tabcontent">
            <div class="section">
                <h2>ğŸ’° ç¨³å®šå¸åˆçº¦æµ‹è¯•</h2>
                <p>åœ¨Remixä¸­éƒ¨ç½² COMP5521Dollar åˆçº¦åï¼Œå°†åœ°å€å¤åˆ¶åˆ°è¿™é‡Œï¼š</p>
                <input type="text" id="stablecoinAddr" placeholder="0x..." style="width: 500px;">
                <button onclick="setStablecoinContract()">ğŸ’¾ è®¾ç½®åˆçº¦åœ°å€</button>
                <div id="stablecoinStatus"></div>
            </div>

            <div class="section">
                <h3>ç¨³å®šå¸åŠŸèƒ½æµ‹è¯•</h3>
                <button onclick="getTokenInfo()" id="tokenInfoBtn">ğŸ” è·å–ä»£å¸ä¿¡æ¯</button>
                <button onclick="useFaucet()" id="faucetBtn">ğŸš° é¢†å–æµ‹è¯•ä»£å¸</button>
                <button onclick="checkBalance()" id="balanceBtn">ğŸ’° æŸ¥è¯¢ä½™é¢</button>
                
                <div id="stablecoinResults">
                    <!-- æµ‹è¯•ç»“æœå°†æ˜¾ç¤ºåœ¨è¿™é‡Œ -->
                </div>
            </div>
        </div>

        <!-- NFTæµ‹è¯•æ ‡ç­¾é¡µ -->
        <div id="NFT" class="tabcontent">
            <div class="section">
                <h2>ğŸ¨ NFTåˆçº¦æµ‹è¯•</h2>
                <p>åœ¨Remixä¸­éƒ¨ç½² COMP5521NFT åˆçº¦åï¼Œå°†åœ°å€å¤åˆ¶åˆ°è¿™é‡Œï¼š</p>
                <input type="text" id="nftAddr" placeholder="0x..." style="width: 500px;">
                <button onclick="setNFTContract()">ğŸ’¾ è®¾ç½®NFTåˆçº¦åœ°å€</button>
                <div id="nftStatus"></div>
            </div>

            <div class="section">
                <h3>NFTé“¸é€ åŠŸèƒ½</h3>
                <label>å…ƒæ•°æ®URI (GitHub RAW URL):</label><br>
                <textarea id="tokenURI" rows="3" style="width: 500px;">https://raw.githubusercontent.com/chiyaqjh/comp5521/main/metadata/1.json</textarea><br>
                <button onclick="mintNFT()">ğŸ› ï¸ é“¸é€ NFT</button>
                <div id="mintStatus"></div>
            </div>

            <div class="section">
                <h3>NFTæŸ¥è¯¢åŠŸèƒ½</h3>
                <button onclick="getNFTContractInfo()">ğŸ“Š è·å–åˆçº¦ä¿¡æ¯</button>
                <button onclick="loadMyNFTs()">ğŸ”„ åŠ è½½æˆ‘çš„NFT</button>
                <button onclick="getNextTokenId()">ğŸ”¢ è·å–ä¸‹ä¸€ä¸ªToken ID</button>
                
                <div id="nftResults">
                    <!-- NFTæµ‹è¯•ç»“æœå°†æ˜¾ç¤ºåœ¨è¿™é‡Œ -->
                </div>
            </div>

            <div class="section">
                <h3>NFTè¯¦ç»†ä¿¡æ¯æŸ¥è¯¢</h3>
                <label>Token ID:</label>
                <input type="number" id="queryTokenId" value="0" style="width: 100px;">
                <button onclick="queryNFTInfo()">ğŸ” æŸ¥è¯¢NFTä¿¡æ¯</button>
                <div id="nftQueryResults"></div>
            </div>
        </div>

        <!-- å¸‚åœºæµ‹è¯•æ ‡ç­¾é¡µ -->
        <div id="Marketplace" class="tabcontent">
            <div class="section">
                <h2>ğŸª å¸‚åœºåˆçº¦æµ‹è¯•</h2>
                <p>åœ¨Remixä¸­éƒ¨ç½² NFTMarketplace åˆçº¦åï¼Œå°†åœ°å€å¤åˆ¶åˆ°è¿™é‡Œï¼š</p>
                <input type="text" id="marketplaceAddr" placeholder="0x..." style="width: 500px;">
                <button onclick="setMarketplaceContract()">ğŸ’¾ è®¾ç½®å¸‚åœºåˆçº¦åœ°å€</button>
                <div id="marketplaceStatus"></div>
            </div>

            <div class="section">
                <h3>å¸‚åœºåŠŸèƒ½æµ‹è¯•</h3>
                <button onclick="getMarketInfo()">ğŸ“ˆ è·å–å¸‚åœºä¿¡æ¯</button>
                <div id="marketplaceResults">
                    <!-- å¸‚åœºæµ‹è¯•ç»“æœå°†æ˜¾ç¤ºåœ¨è¿™é‡Œ -->
                </div>
            </div>
        </div>

        <!-- è°ƒè¯•ä¿¡æ¯æ ‡ç­¾é¡µ -->
        <div id="Debug" class="tabcontent">
            <div class="section">
                <h2>ğŸ› è°ƒè¯•ä¿¡æ¯</h2>
                <button onclick="clearDebug()">æ¸…ç©ºè°ƒè¯•ä¿¡æ¯</button>
                <button onclick="exportDebugInfo()">ğŸ“¤ å¯¼å‡ºè°ƒè¯•ä¿¡æ¯</button>
                <div id="debugInfo" style="font-family: monospace; font-size: 12px; background: #f5f5f5; padding: 10px; border-radius: 5px; max-height: 400px; overflow-y: auto;"></div>
            </div>
        </div>
    </div>

    <script>
        let currentAccount = null;
        let web3 = null;
        let stablecoinContract = null;
        let stablecoinAddress = null;
        let nftContract = null;
        let nftAddress = null;
        let marketplaceContract = null;
        let marketplaceAddress = null;

        // æ·»åŠ è°ƒè¯•ä¿¡æ¯
        function addDebugInfo(message) {
            const debugDiv = document.getElementById('debugInfo');
            const timestamp = new Date().toLocaleTimeString();
            debugDiv.innerHTML += `[${timestamp}] ${message}<br>`;
            debugDiv.scrollTop = debugDiv.scrollHeight;
        }

        // æ¸…ç©ºè°ƒè¯•ä¿¡æ¯
        function clearDebug() {
            document.getElementById('debugInfo').innerHTML = '';
        }

        // å¯¼å‡ºè°ƒè¯•ä¿¡æ¯
        function exportDebugInfo() {
            const debugInfo = document.getElementById('debugInfo').innerText;
            const blob = new Blob([debugInfo], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'debug_info.txt';
            a.click();
            URL.revokeObjectURL(url);
        }

        // æ˜¾ç¤ºçŠ¶æ€ä¿¡æ¯
        function showStatus(elementId, message, type) {
            const element = document.getElementById(elementId);
            element.innerHTML = message;
            element.className = 'status ' + type;
            addDebugInfo(`${elementId}: ${message}`);
        }

        // æ˜¾ç¤ºæµ‹è¯•ç»“æœ
        function showTestResult(elementId, message, type) {
            const element = document.getElementById(elementId);
            element.innerHTML = `<div class="status ${type}">${message}</div>`;
            addDebugInfo(`${elementId}: ${message}`);
        }

        // æ£€æŸ¥ MetaMask æ˜¯å¦å®‰è£…
        function isMetaMaskInstalled() {
            return typeof window.ethereum !== 'undefined' && window.ethereum.isMetaMask;
        }

        // è¿æ¥ MetaMask
        async function connectMetaMask() {
            const connectBtn = document.getElementById('connectBtn');
            
            if (!isMetaMaskInstalled()) {
                showStatus('walletStatus', 'âŒ æœªæ£€æµ‹åˆ° MetaMaskï¼Œè¯·å…ˆå®‰è£… MetaMask æµè§ˆå™¨æ‰©å±•', 'error');
                connectBtn.disabled = true;
                return;
            }
            
            try {
                showStatus('walletStatus', 'ğŸ”„ æ­£åœ¨è¿æ¥ MetaMask...', 'loading');
                connectBtn.disabled = true;
                
                // åˆå§‹åŒ–web3
                web3 = new Web3(window.ethereum);
                addDebugInfo('Web3 åˆå§‹åŒ–å®Œæˆ');
                
                const accounts = await window.ethereum.request({ 
                    method: 'eth_requestAccounts' 
                });
                
                if (accounts.length === 0) {
                    throw new Error('ç”¨æˆ·æ‹’ç»äº†è¿æ¥è¯·æ±‚');
                }
                
                currentAccount = accounts[0];
                const chainId = await window.ethereum.request({ method: 'eth_chainId' });
                
                showStatus('walletStatus', 'âœ… MetaMask è¿æ¥æˆåŠŸï¼', 'success');
                addDebugInfo(`è¿æ¥åˆ°è´¦æˆ·: ${currentAccount}`);
                addDebugInfo(`ç½‘ç»œé“¾ID: ${chainId}`);
                
                document.getElementById('walletInfo').style.display = 'block';
                document.getElementById('accountAddress').textContent = currentAccount;
                document.getElementById('chainId').textContent = chainId;
                document.getElementById('networkName').textContent = getNetworkName(chainId);
                
                connectBtn.textContent = 'å·²è¿æ¥';
                
            } catch (error) {
                connectBtn.disabled = false;
                if (error.code === 4001) {
                    showStatus('walletStatus', 'âŒ ç”¨æˆ·æ‹’ç»äº†è¿æ¥è¯·æ±‚', 'error');
                } else {
                    showStatus('walletStatus', 'âŒ è¿æ¥å¤±è´¥: ' + error.message, 'error');
                }
                addDebugInfo(`è¿æ¥é”™è¯¯: ${error.message}`);
            }
        }

        // ========== ç¨³å®šå¸åˆçº¦å‡½æ•° ==========
        function setStablecoinContract() {
            const address = document.getElementById('stablecoinAddr').value.trim();
            
            if (!web3) {
                showStatus('stablecoinStatus', 'âŒ è¯·å…ˆè¿æ¥ MetaMask', 'error');
                return;
            }
            
            if (!isValidAddress(address)) {
                showStatus('stablecoinStatus', 'âŒ è¯·è¾“å…¥æœ‰æ•ˆçš„ä»¥å¤ªåŠåœ°å€', 'error');
                return;
            }
            
            try {
                // ç¨³å®šå¸åˆçº¦ABI
                const stablecoinABI = [
                    {
                        "inputs": [],
                        "stateMutability": "nonpayable",
                        "type": "constructor"
                    },
                    {
                        "inputs": [],
                        "name": "faucetAmount",
                        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
                        "stateMutability": "view",
                        "type": "function"
                    },
                    {
                        "inputs": [],
                        "name": "name",
                        "outputs": [{"internalType": "string", "name": "", "type": "string"}],
                        "stateMutability": "view",
                        "type": "function"
                    },
                    {
                        "inputs": [],
                        "name": "symbol",
                        "outputs": [{"internalType": "string", "name": "", "type": "string"}],
                        "stateMutability": "view",
                        "type": "function"
                    },
                    {
                        "inputs": [],
                        "name": "decimals",
                        "outputs": [{"internalType": "uint8", "name": "", "type": "uint8"}],
                        "stateMutability": "view",
                        "type": "function"
                    },
                    {
                        "inputs": [],
                        "name": "totalSupply",
                        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
                        "stateMutability": "view",
                        "type": "function"
                    },
                    {
                        "inputs": [{"internalType": "address", "name": "account", "type": "address"}],
                        "name": "balanceOf",
                        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
                        "stateMutability": "view",
                        "type": "function"
                    },
                    {
                        "inputs": [],
                        "name": "useFaucet",
                        "outputs": [],
                        "stateMutability": "nonpayable",
                        "type": "function"
                    },
                    {
                        "inputs": [],
                        "name": "getTokenInfo",
                        "outputs": [
                            {"internalType": "string", "name": "tokenName", "type": "string"},
                            {"internalType": "string", "name": "tokenSymbol", "type": "string"},
                            {"internalType": "uint256", "name": "tokenTotalSupply", "type": "uint256"},
                            {"internalType": "address", "name": "tokenOwner", "type": "address"}
                        ],
                        "stateMutability": "view",
                        "type": "function"
                    }
                ];
                
                stablecoinAddress = address;
                stablecoinContract = new web3.eth.Contract(stablecoinABI, address);
                
                showStatus('stablecoinStatus', 'âœ… ç¨³å®šå¸åˆçº¦è®¾ç½®æˆåŠŸï¼', 'success');
                addDebugInfo(`ç¨³å®šå¸åˆçº¦åœ°å€: ${address}`);
                
                // è‡ªåŠ¨æµ‹è¯•åˆçº¦è¿æ¥
                testStablecoinConnection();
                
            } catch (error) {
                showStatus('stablecoinStatus', 'âŒ åˆçº¦è®¾ç½®å¤±è´¥: ' + error.message, 'error');
                addDebugInfo(`ç¨³å®šå¸åˆçº¦è®¾ç½®é”™è¯¯: ${error.message}`);
            }
        }

        async function testStablecoinConnection() {
            if (!stablecoinContract) return;
            
            try {
                addDebugInfo('å¼€å§‹æµ‹è¯•ç¨³å®šå¸åˆçº¦è¿æ¥...');
                const name = await stablecoinContract.methods.name().call();
                const symbol = await stablecoinContract.methods.symbol().call();
                
                addDebugInfo(`ç¨³å®šå¸åˆçº¦åç§°: ${name}, ç¬¦å·: ${symbol}`);
                showTestResult('stablecoinResults', `âœ… ç¨³å®šå¸åˆçº¦è¿æ¥æˆåŠŸï¼<br>åç§°: ${name}<br>ç¬¦å·: ${symbol}`, 'success');
                
            } catch (error) {
                addDebugInfo(`ç¨³å®šå¸åˆçº¦è¿æ¥æµ‹è¯•å¤±è´¥: ${error.message}`);
                showTestResult('stablecoinResults', 'âŒ ç¨³å®šå¸åˆçº¦è¿æ¥æµ‹è¯•å¤±è´¥: ' + error.message, 'error');
            }
        }

        async function getTokenInfo() {
            if (!stablecoinContract) {
                showTestResult('stablecoinResults', 'âŒ è¯·å…ˆè®¾ç½®ç¨³å®šå¸åˆçº¦åœ°å€', 'error');
                return;
            }
            
            try {
                showTestResult('stablecoinResults', 'ğŸ”„ è·å–ä»£å¸ä¿¡æ¯ä¸­...', 'loading');
                
                const tokenInfo = await stablecoinContract.methods.getTokenInfo().call();
                
                const result = `
                    âœ… ä»£å¸ä¿¡æ¯è·å–æˆåŠŸï¼<br>
                    <strong>åç§°:</strong> ${tokenInfo.tokenName}<br>
                    <strong>ç¬¦å·:</strong> ${tokenInfo.tokenSymbol}<br>
                    <strong>æ€»ä¾›åº”é‡:</strong> ${web3.utils.fromWei(tokenInfo.tokenTotalSupply, 'ether')} ${tokenInfo.tokenSymbol}<br>
                    <strong>åˆçº¦æ‰€æœ‰è€…:</strong> ${tokenInfo.tokenOwner}
                `;
                
                showTestResult('stablecoinResults', result, 'success');
                addDebugInfo(`ä»£å¸ä¿¡æ¯: ${tokenInfo.tokenName} (${tokenInfo.tokenSymbol})`);
                
            } catch (error) {
                showTestResult('stablecoinResults', 'âŒ è·å–ä»£å¸ä¿¡æ¯å¤±è´¥: ' + error.message, 'error');
                addDebugInfo(`è·å–ä»£å¸ä¿¡æ¯é”™è¯¯: ${error.message}`);
            }
        }

        async function useFaucet() {
            if (!stablecoinContract || !currentAccount) {
                showTestResult('stablecoinResults', 'âŒ è¯·å…ˆè¿æ¥é’±åŒ…å¹¶è®¾ç½®åˆçº¦', 'error');
                return;
            }
            
            try {
                showTestResult('stablecoinResults', 'ğŸ”„ é¢†å–æµ‹è¯•ä»£å¸ä¸­...', 'loading');
                
                const result = await stablecoinContract.methods.useFaucet().send({
                    from: currentAccount
                });
                
                showTestResult('stablecoinResults', `âœ… æˆåŠŸé¢†å–æµ‹è¯•ä»£å¸ï¼<br>äº¤æ˜“å“ˆå¸Œ: ${result.transactionHash}`, 'success');
                addDebugInfo(`æ°´é¾™å¤´äº¤æ˜“: ${result.transactionHash}`);
                
                // è‡ªåŠ¨æŸ¥è¯¢ä½™é¢
                setTimeout(checkBalance, 2000);
                
            } catch (error) {
                showTestResult('stablecoinResults', 'âŒ é¢†å–æµ‹è¯•ä»£å¸å¤±è´¥: ' + error.message, 'error');
                addDebugInfo(`æ°´é¾™å¤´é”™è¯¯: ${error.message}`);
            }
        }

        async function checkBalance() {
            if (!stablecoinContract || !currentAccount) {
                showTestResult('stablecoinResults', 'âŒ è¯·å…ˆè¿æ¥é’±åŒ…å¹¶è®¾ç½®åˆçº¦', 'error');
                return;
            }
            
            try {
                showTestResult('stablecoinResults', 'ğŸ”„ æŸ¥è¯¢ä½™é¢ä¸­...', 'loading');
                
                const balance = await stablecoinContract.methods.balanceOf(currentAccount).call();
                const symbol = await stablecoinContract.methods.symbol().call();
                
                const formattedBalance = web3.utils.fromWei(balance, 'ether');
                
                showTestResult('stablecoinResults', `ğŸ’° æ‚¨çš„ä½™é¢: ${formattedBalance} ${symbol}`, 'success');
                addDebugInfo(`ä½™é¢æŸ¥è¯¢: ${formattedBalance} ${symbol}`);
                
            } catch (error) {
                showTestResult('stablecoinResults', 'âŒ æŸ¥è¯¢ä½™é¢å¤±è´¥: ' + error.message, 'error');
                addDebugInfo(`ä½™é¢æŸ¥è¯¢é”™è¯¯: ${error.message}`);
            }
        }

        // ========== NFTåˆçº¦å‡½æ•° ==========
        function setNFTContract() {
            const address = document.getElementById('nftAddr').value.trim();
            
            if (!web3) {
                showStatus('nftStatus', 'âŒ è¯·å…ˆè¿æ¥ MetaMask', 'error');
                return;
            }
            
            if (!isValidAddress(address)) {
                showStatus('nftStatus', 'âŒ è¯·è¾“å…¥æœ‰æ•ˆçš„ä»¥å¤ªåŠåœ°å€', 'error');
                return;
            }
            
            try {
                // NFTåˆçº¦ABI - æ ¹æ®æ‚¨æä¾›çš„COMP5521NFTåˆçº¦
                const nftABI = [
                    {
                        "inputs": [],
                        "stateMutability": "nonpayable",
                        "type": "constructor"
                    },
                    {
                        "inputs": [
                            {"internalType": "address", "name": "to", "type": "address"},
                            {"internalType": "string", "name": "metadataURI", "type": "string"}
                        ],
                        "name": "safeMint",
                        "outputs": [],
                        "stateMutability": "nonpayable",
                        "type": "function"
                    },
                    {
                        "inputs": [],
                        "name": "name",
                        "outputs": [{"internalType": "string", "name": "", "type": "string"}],
                        "stateMutability": "view",
                        "type": "function"
                    },
                    {
                        "inputs": [],
                        "name": "symbol",
                        "outputs": [{"internalType": "string", "name": "", "type": "string"}],
                        "stateMutability": "view",
                        "type": "function"
                    },
                    {
                        "inputs": [{"internalType": "uint256", "name": "tokenId", "type": "uint256"}],
                        "name": "ownerOf",
                        "outputs": [{"internalType": "address", "name": "", "type": "address"}],
                        "stateMutability": "view",
                        "type": "function"
                    },
                    {
                        "inputs": [{"internalType": "uint256", "name": "tokenId", "type": "uint256"}],
                        "name": "tokenURI",
                        "outputs": [{"internalType": "string", "name": "", "type": "string"}],
                        "stateMutability": "view",
                        "type": "function"
                    },
                    {
                        "inputs": [],
                        "name": "totalSupply",
                        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
                        "stateMutability": "view",
                        "type": "function"
                    },
                    {
                        "inputs": [],
                        "name": "getNextTokenId",
                        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
                        "stateMutability": "view",
                        "type": "function"
                    },
                    {
                        "inputs": [
                            {"internalType": "uint256", "name": "tokenId", "type": "uint256"}
                        ],
                        "name": "getNFTInfo",
                        "outputs": [
                            {"internalType": "address", "name": "tokenOwner", "type": "address"},
                            {"internalType": "string", "name": "metadataURI", "type": "string"},
                            {"internalType": "address", "name": "creator", "type": "address"},
                            {"internalType": "uint256", "name": "createdTime", "type": "uint256"},
                            {"internalType": "uint256", "name": "totalMinted", "type": "uint256"}
                        ],
                        "stateMutability": "view",
                        "type": "function"
                    },
                    {
                        "inputs": [],
                        "name": "owner",
                        "outputs": [{"internalType": "address", "name": "", "type": "address"}],
                        "stateMutability": "view",
                        "type": "function"
                    }
                ];
                
                nftAddress = address;
                nftContract = new web3.eth.Contract(nftABI, address);
                
                showStatus('nftStatus', 'âœ… NFTåˆçº¦è®¾ç½®æˆåŠŸï¼', 'success');
                addDebugInfo(`NFTåˆçº¦åœ°å€: ${address}`);
                
                // è‡ªåŠ¨æµ‹è¯•NFTåˆçº¦è¿æ¥
                testNFTConnection();
                
            } catch (error) {
                showStatus('nftStatus', 'âŒ NFTåˆçº¦è®¾ç½®å¤±è´¥: ' + error.message, 'error');
                addDebugInfo(`NFTåˆçº¦è®¾ç½®é”™è¯¯: ${error.message}`);
            }
        }

        async function testNFTConnection() {
            if (!nftContract) return;
            
            try {
                addDebugInfo('å¼€å§‹æµ‹è¯•NFTåˆçº¦è¿æ¥...');
                const name = await nftContract.methods.name().call();
                const symbol = await nftContract.methods.symbol().call();
                const owner = await nftContract.methods.owner().call();
                
                addDebugInfo(`NFTåˆçº¦åç§°: ${name}, ç¬¦å·: ${symbol}, æ‰€æœ‰è€…: ${owner}`);
                showTestResult('nftResults', `âœ… NFTåˆçº¦è¿æ¥æˆåŠŸï¼<br>åç§°: ${name}<br>ç¬¦å·: ${symbol}<br>åˆçº¦æ‰€æœ‰è€…: ${owner}`, 'success');
                
            } catch (error) {
                addDebugInfo(`NFTåˆçº¦è¿æ¥æµ‹è¯•å¤±è´¥: ${error.message}`);
                showTestResult('nftResults', 'âŒ NFTåˆçº¦è¿æ¥æµ‹è¯•å¤±è´¥: ' + error.message, 'error');
            }
        }

        async function mintNFT() {
            if (!nftContract || !currentAccount) {
                showStatus('mintStatus', 'âŒ è¯·å…ˆè¿æ¥é’±åŒ…å¹¶è®¾ç½®NFTåˆçº¦', 'error');
                return;
            }
            
            const tokenURI = document.getElementById('tokenURI').value.trim();
            if (!tokenURI) {
                showStatus('mintStatus', 'âŒ è¯·è¾“å…¥å…ƒæ•°æ®URI', 'error');
                return;
            }
            
            try {
                showStatus('mintStatus', 'ğŸ”„ é“¸é€ NFTä¸­...', 'loading');
                addDebugInfo(`å¼€å§‹é“¸é€ NFTï¼Œå…ƒæ•°æ®URI: ${tokenURI}`);
                
                const result = await nftContract.methods.safeMint(currentAccount, tokenURI).send({
                    from: currentAccount
                });
                
                showStatus('mintStatus', `âœ… NFTé“¸é€ æˆåŠŸï¼<br>äº¤æ˜“å“ˆå¸Œ: ${result.transactionHash}`, 'success');
                addDebugInfo(`NFTé“¸é€ äº¤æ˜“: ${result.transactionHash}`);
                
                // è‡ªåŠ¨åˆ·æ–°NFTä¿¡æ¯
                setTimeout(() => {
                    getNFTContractInfo();
                    loadMyNFTs();
                }, 3000);
                
            } catch (error) {
                showStatus('mintStatus', 'âŒ NFTé“¸é€ å¤±è´¥: ' + error.message, 'error');
                addDebugInfo(`NFTé“¸é€ é”™è¯¯: ${error.message}`);
            }
        }

        async function getNFTContractInfo() {
            if (!nftContract) {
                showTestResult('nftResults', 'âŒ è¯·å…ˆè®¾ç½®NFTåˆçº¦åœ°å€', 'error');
                return;
            }
            
            try {
                showTestResult('nftResults', 'ğŸ”„ è·å–NFTåˆçº¦ä¿¡æ¯ä¸­...', 'loading');
                
                const name = await nftContract.methods.name().call();
                const symbol = await nftContract.methods.symbol().call();
                const totalSupply = await nftContract.methods.totalSupply().call();
                const nextTokenId = await nftContract.methods.getNextTokenId().call();
                const owner = await nftContract.methods.owner().call();
                
                const result = `
                    âœ… NFTåˆçº¦ä¿¡æ¯è·å–æˆåŠŸï¼<br>
                    <strong>åç§°:</strong> ${name}<br>
                    <strong>ç¬¦å·:</strong> ${symbol}<br>
                    <strong>æ€»ä¾›åº”é‡:</strong> ${totalSupply}<br>
                    <strong>ä¸‹ä¸€ä¸ªToken ID:</strong> ${nextTokenId}<br>
                    <strong>åˆçº¦æ‰€æœ‰è€…:</strong> ${owner}
                `;
                
                showTestResult('nftResults', result, 'success');
                addDebugInfo(`NFTåˆçº¦ä¿¡æ¯: ${name} (${symbol}), æ€»ä¾›åº”é‡: ${totalSupply}`);
                
            } catch (error) {
                showTestResult('nftResults', 'âŒ è·å–NFTåˆçº¦ä¿¡æ¯å¤±è´¥: ' + error.message, 'error');
                addDebugInfo(`è·å–NFTåˆçº¦ä¿¡æ¯é”™è¯¯: ${error.message}`);
            }
        }

        async function loadMyNFTs() {
            if (!nftContract || !currentAccount) {
                showTestResult('nftResults', 'âŒ è¯·å…ˆè¿æ¥é’±åŒ…å¹¶è®¾ç½®NFTåˆçº¦', 'error');
                return;
            }
            
            try {
                showTestResult('nftResults', 'ğŸ”„ åŠ è½½æˆ‘çš„NFTä¸­...', 'loading');
                
                const totalSupply = await nftContract.methods.totalSupply().call();
                addDebugInfo(`å¼€å§‹åŠ è½½NFTï¼Œæ€»ä¾›åº”é‡: ${totalSupply}`);
                
                let nftsHTML = '<h4>æˆ‘çš„NFTåˆ—è¡¨:</h4>';
                let foundNFTs = 0;
                
                // éå†æ‰€æœ‰å¯èƒ½çš„tokenIdæ¥æŸ¥æ‰¾å±äºå½“å‰ç”¨æˆ·çš„NFT
                for (let i = 0; i < totalSupply; i++) {
                    try {
                        const owner = await nftContract.methods.ownerOf(i).call();
                        if (owner.toLowerCase() === currentAccount.toLowerCase()) {
                            const tokenURI = await nftContract.methods.tokenURI(i).call();
                            nftsHTML += `
                                <div class="nft-item">
                                    <h4>NFT #${i}</h4>
                                    <p><strong>TokenURI:</strong> ${tokenURI}</p>
                                    <p><strong>æ‰€æœ‰è€…:</strong> ${owner}</p>
                                </div>
                            `;
                            foundNFTs++;
                        }
                    } catch (error) {
                        // è·³è¿‡ä¸å­˜åœ¨çš„tokenId
                        continue;
                    }
                }
                
                if (foundNFTs === 0) {
                    nftsHTML += '<p>æœªæ‰¾åˆ°æ‚¨æ‹¥æœ‰çš„NFT</p>';
                }
                
                showTestResult('nftResults', nftsHTML, 'success');
                addDebugInfo(`æ‰¾åˆ° ${foundNFTs} ä¸ªå±äºæ‚¨çš„NFT`);
                
            } catch (error) {
                showTestResult('nftResults', 'âŒ åŠ è½½NFTå¤±è´¥: ' + error.message, 'error');
                addDebugInfo(`åŠ è½½NFTé”™è¯¯: ${error.message}`);
            }
        }

        async function getNextTokenId() {
            if (!nftContract) {
                showTestResult('nftResults', 'âŒ è¯·å…ˆè®¾ç½®NFTåˆçº¦åœ°å€', 'error');
                return;
            }
            
            try {
                const nextTokenId = await nftContract.methods.getNextTokenId().call();
                showTestResult('nftResults', `ä¸‹ä¸€ä¸ªå¯ç”¨çš„Token ID: ${nextTokenId}`, 'success');
                addDebugInfo(`ä¸‹ä¸€ä¸ªToken ID: ${nextTokenId}`);
                
            } catch (error) {
                showTestResult('nftResults', 'âŒ è·å–ä¸‹ä¸€ä¸ªToken IDå¤±è´¥: ' + error.message, 'error');
                addDebugInfo(`è·å–ä¸‹ä¸€ä¸ªToken IDé”™è¯¯: ${error.message}`);
            }
        }

        async function queryNFTInfo() {
            if (!nftContract) {
                showTestResult('nftQueryResults', 'âŒ è¯·å…ˆè®¾ç½®NFTåˆçº¦åœ°å€', 'error');
                return;
            }
            
            const tokenId = document.getElementById('queryTokenId').value;
            
            try {
                showTestResult('nftQueryResults', 'ğŸ”„ æŸ¥è¯¢NFTä¿¡æ¯ä¸­...', 'loading');
                
                const nftInfo = await nftContract.methods.getNFTInfo(tokenId).call();
                
                // ç›´æ¥ä½¿ç”¨å­—ç¬¦ä¸²æ˜¾ç¤ºï¼Œé¿å…ç±»å‹è½¬æ¢
                const result = `
                    âœ… NFT #${tokenId} ä¿¡æ¯è·å–æˆåŠŸï¼<br>
                    <strong>å½“å‰æ‰€æœ‰è€…:</strong> ${nftInfo.tokenOwner}<br>
                    <strong>å…ƒæ•°æ®URI:</strong> ${nftInfo.metadataURI}<br>
                    <strong>åˆ›ä½œè€…:</strong> ${nftInfo.creator}<br>
                    <strong>åˆ›å»ºæ—¶é—´:</strong> æ—¶é—´æˆ³: ${nftInfo.createdTime}<br>
                    <strong>ä¸‹ä¸€ä¸ªToken ID:</strong> ${nftInfo.totalMinted}
                `;
                
                showTestResult('nftQueryResults', result, 'success');
                addDebugInfo(`NFT #${tokenId} ä¿¡æ¯æŸ¥è¯¢æˆåŠŸ`);
                
            } catch (error) {
                showTestResult('nftQueryResults', 'âŒ æŸ¥è¯¢NFTä¿¡æ¯å¤±è´¥: ' + error.message, 'error');
                addDebugInfo(`æŸ¥è¯¢NFTä¿¡æ¯é”™è¯¯: ${error.message}`);
                }
            }


        // ========== å¸‚åœºåˆçº¦å‡½æ•° ==========
        function setMarketplaceContract() {
            const address = document.getElementById('marketplaceAddr').value.trim();
            
            if (!web3) {
                showStatus('marketplaceStatus', 'âŒ è¯·å…ˆè¿æ¥ MetaMask', 'error');
                return;
            }
            
            if (!isValidAddress(address)) {
                showStatus('marketplaceStatus', 'âŒ è¯·è¾“å…¥æœ‰æ•ˆçš„ä»¥å¤ªåŠåœ°å€', 'error');
                return;
            }
            
            try {
                // å¸‚åœºåˆçº¦ABI - ç®€åŒ–ç‰ˆï¼Œæ ¹æ®å®é™…åˆçº¦è°ƒæ•´
                const marketplaceABI = [
                    {
                        "inputs": [{"internalType": "address", "name": "_stablecoin", "type": "address"}],
                        "stateMutability": "nonpayable",
                        "type": "constructor"
                    },
                    {
                        "inputs": [],
                        "name": "getMarketInfo",
                        "outputs": [
                            {"internalType": "address", "name": "marketStablecoin", "type": "address"},
                            {"internalType": "address", "name": "marketFeeRecipient", "type": "address"},
                            {"internalType": "uint256", "name": "marketFeePercentage", "type": "uint256"}
                        ],
                        "stateMutability": "view",
                        "type": "function"
                    }
                ];
                
                marketplaceAddress = address;
                marketplaceContract = new web3.eth.Contract(marketplaceABI, address);
                
                showStatus('marketplaceStatus', 'âœ… å¸‚åœºåˆçº¦è®¾ç½®æˆåŠŸï¼', 'success');
                addDebugInfo(`å¸‚åœºåˆçº¦åœ°å€: ${address}`);
                
            } catch (error) {
                showStatus('marketplaceStatus', 'âŒ å¸‚åœºåˆçº¦è®¾ç½®å¤±è´¥: ' + error.message, 'error');
                addDebugInfo(`å¸‚åœºåˆçº¦è®¾ç½®é”™è¯¯: ${error.message}`);
            }
        }

        async function getMarketInfo() {
            if (!marketplaceContract) {
                showTestResult('marketplaceResults', 'âŒ è¯·å…ˆè®¾ç½®å¸‚åœºåˆçº¦åœ°å€', 'error');
                return;
            }
            
            try {
                showTestResult('marketplaceResults', 'ğŸ”„ è·å–å¸‚åœºä¿¡æ¯ä¸­...', 'loading');
                
                const marketInfo = await marketplaceContract.methods.getMarketInfo().call();
                
                const result = `
                    âœ… å¸‚åœºä¿¡æ¯è·å–æˆåŠŸï¼<br>
                    <strong>ç¨³å®šå¸åœ°å€:</strong> ${marketInfo.marketStablecoin}<br>
                    <strong>è´¹ç”¨æ¥æ”¶åœ°å€:</strong> ${marketInfo.marketFeeRecipient}<br>
                    <strong>æ‰‹ç»­è´¹ç‡:</strong> ${marketInfo.marketFeePercentage / 100}%
                `;
                
                showTestResult('marketplaceResults', result, 'success');
                addDebugInfo(`å¸‚åœºä¿¡æ¯æŸ¥è¯¢æˆåŠŸ`);
                
            } catch (error) {
                showTestResult('marketplaceResults', 'âŒ è·å–å¸‚åœºä¿¡æ¯å¤±è´¥: ' + error.message, 'error');
                addDebugInfo(`è·å–å¸‚åœºä¿¡æ¯é”™è¯¯: ${error.message}`);
            }
        }

        // ========== å·¥å…·å‡½æ•° ==========
        function getNetworkName(chainId) {
            const networks = {
                '0x1': 'ä»¥å¤ªåŠä¸»ç½‘',
                '0xaa36a7': 'Sepoliaæµ‹è¯•ç½‘',
                '0x5': 'Goerliæµ‹è¯•ç½‘',
                '0x539': 'æœ¬åœ°å¼€å‘ç½‘ç»œ'
            };
            return networks[chainId] || `æœªçŸ¥ç½‘ç»œ (${chainId})`;
        }

        function isValidAddress(address) {
            return /^0x[a-fA-F0-9]{40}$/.test(address);
        }

        // é€‰é¡¹å¡åŠŸèƒ½
        function openTab(evt, tabName) {
            const tabcontent = document.getElementsByClassName("tabcontent");
            for (let i = 0; i < tabcontent.length; i++) {
                tabcontent[i].style.display = "none";
            }
            
            const tablinks = document.getElementsByClassName("tablinks");
            for (let i = 0; i < tablinks.length; i++) {
                tablinks[i].className = tablinks[i].className.replace(" active", "");
            }
            
            document.getElementById(tabName).style.display = "block";
            evt.currentTarget.className += " active";
        }

        // é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–
        window.addEventListener('load', function() {
            addDebugInfo('é¡µé¢åŠ è½½å®Œæˆ');
            
            if (isMetaMaskInstalled()) {
                showStatus('walletStatus', 'âœ… å·²æ£€æµ‹åˆ° MetaMaskï¼Œç‚¹å‡»ä¸Šæ–¹æŒ‰é’®è¿æ¥', 'success');
                
                // ç›‘å¬è´¦æˆ·å˜åŒ–
                window.ethereum.on('accountsChanged', (accounts) => {
                    if (accounts.length === 0) {
                        showStatus('walletStatus', 'ğŸ”’ é’±åŒ…å·²æ–­å¼€è¿æ¥', 'error');
                        document.getElementById('walletInfo').style.display = 'none';
                        document.getElementById('connectBtn').disabled = false;
                        document.getElementById('connectBtn').textContent = 'è¿æ¥ MetaMask';
                        currentAccount = null;
                    } else {
                        currentAccount = accounts[0];
                        document.getElementById('accountAddress').textContent = currentAccount;
                        addDebugInfo(`è´¦æˆ·åˆ‡æ¢ä¸º: ${currentAccount}`);
                    }
                });
                
                // ç›‘å¬ç½‘ç»œå˜åŒ–
                window.ethereum.on('chainChanged', (chainId) => {
                    document.getElementById('chainId').textContent = chainId;
                    document.getElementById('networkName').textContent = getNetworkName(chainId);
                    addDebugInfo(`ç½‘ç»œåˆ‡æ¢ä¸º: ${getNetworkName(chainId)} (${chainId})`);
                });
                
            } else {
                showStatus('walletStatus', 'âŒ æœªæ£€æµ‹åˆ° MetaMaskï¼Œè¯·å®‰è£… MetaMask æ‰©å±•', 'error');
                document.getElementById('connectBtn').disabled = true;
            }
            
            // é»˜è®¤æ‰“å¼€ç¬¬ä¸€ä¸ªæ ‡ç­¾é¡µ
            document.getElementsByClassName('tablinks')[0].click();
        });
    </script>
</body>
</html>